import dask_gateway

# cluster = None
gateway = dask_gateway.Gateway()
cluster_options = gateway.cluster_options()


## Dask Functions
def check_for_existing_clusters():
    if len(gateway.list_clusters()) == 0:
        return False   
    return True

#max is 227
def setup_dask_cluster(max=227, mem=16):
    cluster_options["worker_memory"] = mem
    
    if check_for_existing_clusters():
        print ("Clusters already exist, latching onto the first one")
        
        clusters = gateway.list_clusters()
        cluster = gateway.connect(clusters[0].name)
        
        client = cluster.get_client()
        
    else :
        cluster = gateway.new_cluster(cluster_options, shutdown_on_close=False)
        client = cluster.get_client()
        cluster.adapt(minimum=2, maximum=max)
    
    
    print(client)
    print(cluster.dashboard_link)

    
def shutdown_all_clusters():
    
    clusters = gateway.list_clusters()
    if clusters is not None:
        for c in clusters:
            cluster = gateway.connect(c.name)
            cluster.shutdown()
            print (cluster)
    
# This function will be used to 'override' dask.conpute
# check if dask clusters are alive, if so, latch onto it
# otherwise spawn a new cluster and do .compute on df
def compute(ddf):
    setup_dask_cluster()
    return ddf.compute()

def dashboard():
    return cluster.dashboard_link


## Grid Functions

import shapely
import numpy as np

#Generate an equally spaced grid set within the bounds of a given polygon

from shapely.geometry import Point

def grid_point_generator(gpd_polygon, grid_size, c='epsg:4326'):   
    """
    Generates a set of equally spaced points (by input <grid_size>) within the boundaries indicated
    by input <gpd_polygon>
    """
    
    south=gpd_polygon.total_bounds[1]
    west=gpd_polygon.total_bounds[0]
    north=gpd_polygon.total_bounds[3]
    east=gpd_polygon.total_bounds[2]
    x=west
    summary=[]
    while x <= east:
        y=south
        while y<= north:
            summary.append([Point(x, y)])
            y=y+grid_size[0]
        x=x+grid_size[1]
    summary_df=gpd.GeoDataFrame(summary, columns=['geometry'], crs=c)
    return summary_df

def get_square_around_point(point_geom, gsize):
    
    delta_size = gsize / 2.0
    point_coords = np.array(point_geom.coords[0])

    c1 = point_coords + [-delta_size,-delta_size]
    c2 = point_coords + [-delta_size,+delta_size]
    c3 = point_coords + [+delta_size,+delta_size]
    c4 = point_coords + [+delta_size,-delta_size]
    
    square_geom = shapely.geometry.Polygon([c1,c2,c3,c4])
    
    return square_geom

def get_gdf_with_grids(gdf_with_points, gsize=0.01):
    """
    Takes a geopandas frame as an input (<gdf_with_points>) which contains equally spaces points 
    (typically generated by function grid_point_generator) and produces adjacent grids of size <gsize>
    """
        
    gdf_grid = gdf_with_points.copy()
    gdf_grid['geometry'] = gdf_with_points.apply(lambda row: get_square_around_point(row['geometry'],gsize), axis=1)
    return gdf_grid


## Gridding with h3

import geopandas as gpd
from h3 import h3
from shapely.geometry import Polygon


#Note: does not currently work with multi-polygons. Check this tutorial for multi polygons
# https://towardsdatascience.com/uber-h3-for-data-analysis-with-python-1e54acdcc908

def get_gdf_with_h3(aoi, h3_level=4):
    """
    inputs:
        aoi: Area of interest -> geopandas frame with a single polygon that contains the area of interest
        h3_level: resolution of hexagons (higher is more resolution)
        
    outputs:
        geopandas df that consists of a list of contiguous hexagons and the global h3 id associated with each shape.
        
    Notes: 
        This will generate polygons that have a center within the polygon. To get exact, we will need to clip it to the AMMB boundary
    """

    hexs = h3.polyfill(aoi.geometry[0].__geo_interface__, h3_level, geo_json_conformant = True)
    
    polygonise = lambda hex_id: Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True))

    all_polys = gpd.GeoSeries(list(map(polygonise, hexs)), \
                                      index=hexs, \
                                      crs="EPSG:4326")
    # Convert to geopandas df:
    out_h3 = gpd.GeoDataFrame({"geometry": all_polys,
                            "hex_id": all_polys.index},
                            crs=all_polys.crs
                            ).reset_index()
    
    out_h3.drop('index', axis=1, inplace=True)

    return out_h3




def get_world_h3(h3_level=4):
    """
    Generates a h3 gridded world in the default EPSG4326 projection
    inputs:
        h3_level: resolution of hexagons (higher is more resolution)
        
    outputs:
        geopandas df that consists of a list of contiguous hexagons and the global h3 id associated with each shape.
        
    Notes: 
        This function splits the world into 2 halves to generate this.
    """

    lon_point_list = [180,180,0,0]
    lat_point_list = [90,-90,-90,90]

    polygon_geom = Polygon(zip(lon_point_list, lat_point_list))
    crs = {'init': 'epsg:4326'}
    world_e_poly = gpd.GeoDataFrame(crs=crs, geometry=[polygon_geom]) 
    world_e_h3 = get_gdf_with_h3(world_e_poly,h3_level)
    
    lon_point_list = [-180,-180,0,0]
    lat_point_list = [90,-90,-90,90]

    polygon_geom = Polygon(zip(lon_point_list, lat_point_list))
    crs = {'init': 'epsg:4326'}
    world_w_poly = gpd.GeoDataFrame(crs=crs, geometry=[polygon_geom]) 
    world_w_h3 = get_gdf_with_h3(world_w_poly,h3_level)
    
    #combine
    world_h3 = world_e_h3.append(world_w_h3)
    
    return world_h3
